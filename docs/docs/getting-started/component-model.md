---
title: Component Model Tutorial
sidebar_position: 3
---

With the Component Model API of WaaS, you can run components based on the [WebAssembly Component Model](https://component-model.bytecodealliance.org/).

While traditional WebAssembly modules were limited to numeric types for arguments and return values, the Component Model allows for more complex data types such as strings, lists, and structures to be exchanged.

### 1. Creating WIT

In the Component Model, you define types and function signatures in advance using an IDL called [**WIT**](https://component-model.bytecodealliance.org/design/wit.html) (WebAssembly Interface Type). The following is an example of a WIT intended for use in a simple conversation scene:

```wit
package my-game:my-sequencer;

world sequence {
    import env;
    export play: func();
}

interface env {
    show-message: func(speaker: string, message: string);
    show-options: func(options: list<string>) -> u32;
}
```

`world` defines the set of functions to import and export for this WebAssembly component. `interface env` defines the set of functions to be implemented on the host environment side and imported into the component.

### 2. Guest Language Work

Once you have created the WIT, generate bindings for each guest language from the WIT. Use the tool [`wit-bindgen`](https://github.com/bytecodealliance/wit-bindgen) for this purpose. Currently, it supports generating bindings for Rust, C, Java, Go, C#, and Moonbit. For Rust, a tool called [`cargo-component`](https://github.com/bytecodealliance/cargo-component) is available to incorporate code generation from WIT into the build pipeline, so we will use it this time.

```sh
cargo install cargo-component --locked
```

Create a new Rust workspace.

```sh
cargo component new hello-world --lib
```

Place the WIT from earlier in `wit/world.wit`.

The following is an example of a script written using the generated bindings for Rust. It calls the functions defined in `interface env`.

```rust
#[allow(warnings)]
mod bindings;

use bindings::my_game::my_sequencer::env::*;
use bindings::Guest;

struct Component;

impl Guest for Component {
    fn play() {
        show_message("Sigmo", "Would you mind bringing me a battery?");
        match show_options(&["Sure".to_string(), "No".to_string()]) {
            0 => show_message("Sigmo", "Thank you!"),
            1 => show_message("Sigmo", "……"),
            _ => {}
        }
        show_message("Sigmo", "……");
    }
}

bindings::export!(Component with_types_in bindings);
```

With `cargo-component`, the following command generates bindings from WIT and creates the component:

```sh
cargo component build --release --target wasm32-unknown-unknown
```

The result will be output to `target/wasm32-unknown-unknown/release/hello_world.wasm`. Import this into your Unity project.

### 3. C# Work

Now, before you can actually run the component, you need to implement `show-message` and `show-options` on the C# side. To do this, you first need to convert the WIT to C# interfaces using the `wit2waas` tool provided by WaaS. This will generate the following C# code from the WIT above:

```csharp
// <auto-generated />
#nullable enable

namespace MyGame.MySequencer
{
    [global::WaaS.ComponentModel.Binding.ComponentInterface(@"env")]
    public partial interface IEnv
    {
        [global::WaaS.ComponentModel.Binding.ComponentApi(@"show-message")]
        global::System.Threading.Tasks.ValueTask ShowMessage(string @speaker, string @message);

        [global::WaaS.ComponentModel.Binding.ComponentApi(@"show-options")]
        global::System.Threading.Tasks.ValueTask<uint> ShowOptions(global::System.ReadOnlyMemory<string> @options);

    }
}
```

There are various attributes attached to the generated code, which allow the Source Generator to generate the code that actually exchanges values between the WebAssembly component and C#.

Then implement the `IEnv`.

```csharp
class Env : IEnv
{
    public static readonly Env Instance = new();

    public async ValueTask ShowMessage(string speaker, string message)
    {
        Debug.Log($"{speaker}: {message}");
    }

    public async ValueTask<uint> ShowOptions(ReadOnlyMemory<string> options)
    {
        Debug.Log($"Options: {string.Join(", ", options.ToArray())}");
        return 0;
    }
}
```

Now it's time to run the component. Pass an instance of a class that implements `IEnv` to the component, and `ShowMessage()` and `ShowOptions()` will be called from within the component.

```csharp
[SerializeField] private ComponentAsset componentAsset;

var component = componentAsset.LoadComponent();

// Instantiate the component
var instance = component.Instantiate(null, new Dictionary<string, ISortedExportable>()
{
    // Import the `env` implementation
    { "my-game:my-sequencer/env", IEnv.CreateWaaSInstance(Env.Instance) }
});

using var context = new ExecutionContext();
var wrapper = new ISequence.Wrapper(instance, context);

// Run
await wrapper.Play();
```


