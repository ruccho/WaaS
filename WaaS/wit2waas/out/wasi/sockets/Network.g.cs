// <auto-generated />
#nullable enable

namespace Wasi.Sockets
{
    [global::WaaS.ComponentModel.Binding.ComponentInterface(@"network")]
    public partial interface INetwork
    {
        /// <summary>
        ///     An opaque resource that represents access to (a subset of) the network.
        ///     This enables context-based security for networking.
        ///     There is no need for this to map 1:1 to a physical network interface.
        /// </summary>
        [global::WaaS.ComponentModel.Binding.ComponentResource]
        public partial interface INetworkResource : global::WaaS.ComponentModel.Runtime.IResourceType
        {
        }

        /// <summary>
        ///     Error codes.
        ///     
        ///     In theory, every API can return any error code.
        ///     In practice, API's typically only return the errors documented per API
        ///     combined with a couple of errors that are always possible:
        ///     - `unknown`
        ///     - `access-denied`
        ///     - `not-supported`
        ///     - `out-of-memory`
        ///     - `concurrency-conflict`
        ///     
        ///     See each individual API for what the POSIX equivalents are. They sometimes differ per API.
        /// </summary>
        public enum ErrorCode : uint
        {
            /// <summary>
            ///     Unknown error
            /// </summary>
            Unknown,
            /// <summary>
            ///     Access denied.
            ///     
            ///     POSIX equivalent: EACCES, EPERM
            /// </summary>
            AccessDenied,
            /// <summary>
            ///     The operation is not supported.
            ///     
            ///     POSIX equivalent: EOPNOTSUPP
            /// </summary>
            NotSupported,
            /// <summary>
            ///     One of the arguments is invalid.
            ///     
            ///     POSIX equivalent: EINVAL
            /// </summary>
            InvalidArgument,
            /// <summary>
            ///     Not enough memory to complete the operation.
            ///     
            ///     POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
            /// </summary>
            OutOfMemory,
            /// <summary>
            ///     The operation timed out before it could finish completely.
            /// </summary>
            Timeout,
            /// <summary>
            ///     This operation is incompatible with another asynchronous operation that is already in progress.
            ///     
            ///     POSIX equivalent: EALREADY
            /// </summary>
            ConcurrencyConflict,
            /// <summary>
            ///     Trying to finish an asynchronous operation that:
            ///     - has not been started yet, or:
            ///     - was already finished by a previous `finish-*` call.
            ///     
            ///     Note: this is scheduled to be removed when `future`s are natively supported.
            /// </summary>
            NotInProgress,
            /// <summary>
            ///     The operation has been aborted because it could not be completed immediately.
            ///     
            ///     Note: this is scheduled to be removed when `future`s are natively supported.
            /// </summary>
            WouldBlock,
            /// <summary>
            ///     The operation is not valid in the socket's current state.
            /// </summary>
            InvalidState,
            /// <summary>
            ///     A new socket resource could not be created because of a system limit.
            /// </summary>
            NewSocketLimit,
            /// <summary>
            ///     A bind operation failed because the provided address is not an address that the `network` can bind to.
            /// </summary>
            AddressNotBindable,
            /// <summary>
            ///     A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
            /// </summary>
            AddressInUse,
            /// <summary>
            ///     The remote address is not reachable
            /// </summary>
            RemoteUnreachable,
            /// <summary>
            ///     The TCP connection was forcefully rejected
            /// </summary>
            ConnectionRefused,
            /// <summary>
            ///     The TCP connection was reset.
            /// </summary>
            ConnectionReset,
            /// <summary>
            ///     A TCP connection was aborted.
            /// </summary>
            ConnectionAborted,
            /// <summary>
            ///     The size of a datagram sent to a UDP socket exceeded the maximum
            ///     supported size.
            /// </summary>
            DatagramTooLarge,
            /// <summary>
            ///     Name does not exist or has no suitable associated IP addresses.
            /// </summary>
            NameUnresolvable,
            /// <summary>
            ///     A temporary failure in name resolution occurred.
            /// </summary>
            TemporaryResolverFailure,
            /// <summary>
            ///     A permanent failure in name resolution occurred.
            /// </summary>
            PermanentResolverFailure,
        }

        public enum IpAddressFamily : uint
        {
            /// <summary>
            ///     Similar to `AF_INET` in POSIX.
            /// </summary>
            Ipv4,
            /// <summary>
            ///     Similar to `AF_INET6` in POSIX.
            /// </summary>
            Ipv6,
        }

        [global::WaaS.ComponentModel.Binding.ComponentAlias(typeof((byte, byte, byte, byte)))]
        public readonly partial struct Ipv4Address
        {
            private readonly (byte, byte, byte, byte) value;
            private Ipv4Address ((byte, byte, byte, byte) value) => this.value = value;
            public static implicit operator Ipv4Address((byte, byte, byte, byte) value) => new (value);
            public static implicit operator (byte, byte, byte, byte)(Ipv4Address value) => value.value;
        }

        [global::WaaS.ComponentModel.Binding.ComponentAlias(typeof((ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort)))]
        public readonly partial struct Ipv6Address
        {
            private readonly (ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort) value;
            private Ipv6Address ((ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort) value) => this.value = value;
            public static implicit operator Ipv6Address((ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort) value) => new (value);
            public static implicit operator (ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort)(Ipv6Address value) => value.value;
        }

        [global::WaaS.ComponentModel.Binding.ComponentVariant]
        public readonly partial struct IpAddress
        {
            [global::WaaS.ComponentModel.Binding.ComponentCaseAttribute]
            public Wasi.Sockets.INetwork.Ipv4Address? Ipv4 { get; init; }
            [global::WaaS.ComponentModel.Binding.ComponentCaseAttribute]
            public Wasi.Sockets.INetwork.Ipv6Address? Ipv6 { get; init; }
        }

        [global::WaaS.ComponentModel.Binding.ComponentRecord]
        public readonly partial struct Ipv4SocketAddress
        {
            /// <summary>
            ///     sin_port
            /// </summary>
            [global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]
            public ushort Port { get; init; }
            /// <summary>
            ///     sin_addr
            /// </summary>
            [global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]
            public Wasi.Sockets.INetwork.Ipv4Address Address { get; init; }
        }

        [global::WaaS.ComponentModel.Binding.ComponentRecord]
        public readonly partial struct Ipv6SocketAddress
        {
            /// <summary>
            ///     sin6_port
            /// </summary>
            [global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]
            public ushort Port { get; init; }
            /// <summary>
            ///     sin6_flowinfo
            /// </summary>
            [global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]
            public uint FlowInfo { get; init; }
            /// <summary>
            ///     sin6_addr
            /// </summary>
            [global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]
            public Wasi.Sockets.INetwork.Ipv6Address Address { get; init; }
            /// <summary>
            ///     sin6_scope_id
            /// </summary>
            [global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]
            public uint ScopeId { get; init; }
        }

        [global::WaaS.ComponentModel.Binding.ComponentVariant]
        public readonly partial struct IpSocketAddress
        {
            [global::WaaS.ComponentModel.Binding.ComponentCaseAttribute]
            public Wasi.Sockets.INetwork.Ipv4SocketAddress? Ipv4 { get; init; }
            [global::WaaS.ComponentModel.Binding.ComponentCaseAttribute]
            public Wasi.Sockets.INetwork.Ipv6SocketAddress? Ipv6 { get; init; }
        }

    }
}
