mod source;

use std::fs;
use std::os::windows::fs::FileTypeExt;
use wit_parser::{Handle, Interface, Package, PackageId, Resolve, Type, TypeDef, TypeDefKind, TypeOwner, World};
use anyhow::{Result};
use crate::source::Source;

fn main() {
    for entry in fs::read_dir("wasi").unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        let path = path.to_str().unwrap();

        let ty = entry.file_type().unwrap();
        if ty.is_dir() || ty.is_symlink_dir() {
            let mut resolve = Resolve::default();
            let (id, _) = resolve.push_dir(&format!("{path}/wit")).unwrap();
            process_dir(&resolve, id).unwrap();
        }
    }
}

fn process_dir(resolve: &Resolve, package_id: PackageId) -> Result<()> {
    let package = resolve.packages.get(package_id).unwrap();
    for (name, id) in &package.interfaces {
        let interface = resolve.interfaces.get(id.clone()).unwrap();

        let mut source = Source::default();

        source.push_line("// <auto-generated />");
        source.push_line("#nullable enable");

        source.push_line(&format!("namespace {}", package.to_waas(resolve)?));
        source.open_block();
        {
            source.push_line("[global::WaaS.ComponentModel.Binding.ComponentInterface]");
            source.push_line(&format!("public partial interface {}", to_upper_camel(&name)));
            source.open_block();
            {
                for (name, function) in &interface.functions {
                    let mut line: String = "".to_string();
                    // return type
                    let results = &function.results;
                    match results.len() {
                        0 => line.push_str("void"),
                        1 => line.push_str(&results.iter_types().next().unwrap().to_waas(resolve)?),
                        _ => {
                            return Err(anyhow::anyhow!("multiple return values not supported"))
                        }
                    }

                    // function name
                    line.push_str(" ");
                    line.push_str(&to_upper_camel(&name));
                    line.push_str("(");

                    // params
                    let mut first = true;
                    for (name, ty) in &function.params {
                        if first {
                            first = false;
                        } else {
                            line.push_str(", ");
                        }

                        line.push_str(&ty.to_waas(resolve)?);
                        line.push_str(" ");
                        line.push_str(&to_lower_camel(name));
                    }

                    line.push_str(");");
                    source.push_line(&line);
                }
            }
            source.close_block();
        }
        source.close_block();

        let dir = format!("out/{}/{}", package.name.namespace, package.name.name);
        fs::create_dir_all(&dir)?;

        let file = format!("{}/{}.g.cs", dir, to_upper_camel(&name));

        fs::write(&file, source.finish())?;
    }

    Ok(())
}

fn to_upper_camel(name: &str) -> String {
    let mut result = String::new();
    let mut upper = true;
    for c in name.chars() {
        if c == '-' {
            upper = true;
        } else if upper {
            result.push(c.to_ascii_uppercase());
            upper = false;
        } else {
            result.push(c);
        }
    }
    result
}

fn to_lower_camel(name: &str) -> String {
    let mut result = String::new();
    let mut upper = false;
    for c in name.chars() {
        if c == '-' {
            upper = true;
        } else if upper {
            result.push(c.to_ascii_uppercase());
            upper = false;
        } else {
            result.push(c);
        }
    }
    result
}

trait ToWaas {
    fn to_waas(&self, resolve: &Resolve) -> Result<String>;
}

impl ToWaas for Package {
    fn to_waas(&self, resolve: &Resolve) -> Result<String> {
        Ok(format!("{}.{}", to_upper_camel(&self.name.namespace), to_upper_camel(&self.name.name)))
    }
}

impl ToWaas for Type {
    fn to_waas(&self, resolve: &Resolve) -> Result<String> {
        Ok(match self {
            Type::Bool => "bool".into(),
            Type::U8 => "byte".into(),
            Type::U16 => "ushort".into(),
            Type::U32 => "uint".into(),
            Type::U64 => "ulong".into(),
            Type::S8 => "sbyte".into(),
            Type::S16 => "short".into(),
            Type::S32 => "int".into(),
            Type::S64 => "long".into(),
            Type::F32 => "float".into(),
            Type::F64 => "double".into(),
            Type::Char => "global:WaaS.ComponentModel.Binding.ComponentChar".into(),
            Type::String => "string".into(),
            Type::Id(id) => {
                let ty = resolve.types.get(id.clone()).unwrap();
                ty.to_waas(resolve)?
            }
        })
    }
}

impl ToWaas for TypeDef {
    fn to_waas(&self, resolve: &Resolve) -> Result<String> {
        fn to_waas_from_name(ty: &TypeDef, resolve: &Resolve) -> Result<String> {
            match &ty.owner {
                TypeOwner::World(id) => {
                    let world = resolve.worlds.get(id.clone()).unwrap();
                    Ok(format!("{}.{}", world.to_waas(resolve)?, to_upper_camel(&ty.name.clone().unwrap())))
                }
                TypeOwner::Interface(id) => {
                    let interface = resolve.interfaces.get(id.clone()).unwrap();
                    Ok(format!("{}.{}", interface.to_waas(resolve)?, to_upper_camel(&ty.name.clone().unwrap())))
                }
                TypeOwner::None => Err(anyhow::anyhow!("type owner not set"))?,
            }
        }

        match &self.kind {
            TypeDefKind::Record(_) => to_waas_from_name(self, resolve),
            TypeDefKind::Resource => to_waas_from_name(self, resolve),
            TypeDefKind::Handle(element) => {
                match element {
                    Handle::Own(element) => Ok(format!("global::WaaS.ComponentModel.Runtime.Owned<{}>", resolve.types.get(element.clone()).unwrap().to_waas(resolve)?)),
                    Handle::Borrow(element) => Ok(format!("global::WaaS.ComponentModel.Runtime.Borrowed<{}>", resolve.types.get(element.clone()).unwrap().to_waas(resolve)?)),
                }
            }
            TypeDefKind::Flags(_) => to_waas_from_name(self, resolve),
            TypeDefKind::Tuple(element) => {
                let mut result = "(".to_string();
                let mut first = true;
                for ty in &element.types
                {
                    if first {
                        first = false;
                    } else {
                        result.push_str(", ");
                    }
                    result.push_str(&ty.to_waas(resolve)?);
                }
                result.push_str(")");
                Ok(result)
            }
            TypeDefKind::Variant(_) => to_waas_from_name(self, resolve),
            TypeDefKind::Enum(_) => to_waas_from_name(self, resolve),
            TypeDefKind::Option(element) => Ok(format!("global::WaaS.ComponentModel.Binding.Option<{}>", element.to_waas(resolve)?)),
            TypeDefKind::Result(element) => {
                Ok(format!("global::WaaS.ComponentModel.Binding.Result<{}, {}>", match element.ok {
                    None => "global::WaaS.ComponentModel.Binding.None".to_string(),
                    Some(ty) => ty.to_waas(resolve)?
                }, match element.err {
                    None => "global::WaaS.ComponentModel.Binding.None".to_string(),
                    Some(ty) => ty.to_waas(resolve)?
                }))
            }
            TypeDefKind::List(element) => Ok(format!("global::System.ReadOnlyMemory<{}>", element.to_waas(resolve)?)),
            TypeDefKind::Future(_) => todo!(),
            TypeDefKind::Stream(_) => todo!(),
            TypeDefKind::Type(element) => element.to_waas(resolve),
            TypeDefKind::Unknown => Err(anyhow::anyhow!("unknown type def kind"))?,
        }
    }
}

impl ToWaas for World {
    fn to_waas(&self, resolve: &Resolve) -> Result<String> {
        let package = resolve.packages.get(self.package.unwrap()).unwrap();
        Ok(format!("{}.{}", package.to_waas(resolve)?, to_upper_camel(&self.name)))
    }
}

impl ToWaas for Interface {
    fn to_waas(&self, resolve: &Resolve) -> Result<String> {
        let package = resolve.packages.get(self.package.unwrap()).unwrap();
        Ok(format!("{}.{}", package.to_waas(resolve)?, to_upper_camel(&self.name.clone().unwrap())))
    }
}
























