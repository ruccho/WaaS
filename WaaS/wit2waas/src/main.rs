mod source;
mod utils;

use crate::source::Source;
use crate::utils::*;
use anyhow::Result;
use std::fs;
use clap::Parser;
use wit_parser::{Function, FunctionKind, PackageId, Resolve, Type, TypeDefKind, TypeOwner, WorldItem};

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    #[arg(short, long, default_value = "wit")]
    wit_dir: String,

    #[arg(short, long, default_value = "out")]
    out: String,
}

fn main() {
    let args = Args::parse();

    let mut resolve = Resolve::default();
    let (id, _) = resolve.push_dir(args.wit_dir).unwrap();
    process_dir(&resolve, id, &args.out).unwrap();
}

fn process_func(resolve: &Resolve, function: &Function, source: &mut Source) -> Result<()> {
    let name = &function.name;

    // docs
    source.push_docs(&function.docs);

    // attribute
    source.push_line(&format!("[global::WaaS.ComponentModel.Binding.ComponentApi(@\"{}\")]", name));

    let mut line: String = "".to_string();
    // return type
    let results = &function.results;
    match results.len() {
        0 => line.push_str("global::System.Threading.Tasks.ValueTask"),
        1 => line.push_str(&format!("global::System.Threading.Tasks.ValueTask<{}>", &results.iter_types().next().unwrap().to_waas(resolve)?)),
        _ => {
            return Err(anyhow::anyhow!("multiple return values not supported"))
        }
    }

    // function name

    let name = match &function.kind {
        FunctionKind::Freestanding => {
            &function.name
        }
        FunctionKind::Method(_method_type) => {
            if name.starts_with("[method]") {
                &name[name.chars().position(|c| c == '.').unwrap() + 1..]
            } else {
                name
            }
        }
        FunctionKind::Static(_method_type) => {
            if name.starts_with("[static]") {
                &name[name.chars().position(|c| c == '.').unwrap() + 1..]
            } else {
                name
            }
        }
        FunctionKind::Constructor(_method_type) => {
            if name.starts_with("[constructor]") {
                &name.strip_prefix("[constructor]").unwrap().to_string()
            } else {
                name
            }
        }
    };

    line.push(' ');
    line.push_str(&to_upper_camel(name));
    line.push('(');

    // params
    let mut first = true;
    for (name, ty) in &function.params {
        if first {
            first = false;
        } else {
            line.push_str(", ");
        }

        line.push_str(&ty.to_waas(resolve)?);
        line.push_str(" @");
        line.push_str(&to_lower_camel(name));
    }

    line.push_str(");");
    source.push_line(&line);

    Ok(())
}

fn process_dir(resolve: &Resolve, package_id: PackageId, out_dir: &str) -> Result<()> {
    let package = resolve.packages.get(package_id).unwrap();

    let dir = format!("{}/{}/{}", out_dir, package.name.namespace, package.name.name);
    fs::create_dir_all(&dir)?;

    for (name, id) in &package.worlds {
        let world = resolve.worlds.get(*id).unwrap();
        let mut source = Source::default();
        let full_name = format!("{0}:{1}/{2}", package.name.namespace, package.name.name, name);

        source.push_line("// <auto-generated />");
        source.push_line("#nullable enable");
        source.push_line_empty();

        source.push_line(&format!("namespace {}", package.to_waas(resolve)?));
        source.open_block();
        {
            source.push_line(&format!("// world {full_name}"));
            source.push_docs(&world.docs);
            source.push_line(&format!("[global::WaaS.ComponentModel.Binding.ComponentInterface(@\"{}\")]", full_name));

            source.push_line(&format!("public partial interface I{}", to_upper_camel(name)));
            source.open_block();
            {
                for (_key, item) in &world.exports {
                    match item {
                        WorldItem::Interface { id, stability: _stability } => {
                            let interface = resolve.interfaces.get(*id).unwrap();
                            let name = &interface.name.clone().unwrap();
                            source.push_line(&format!("{0} {1} {{ get; }}", &interface.to_waas(resolve)?, to_upper_camel(name)));
                        }
                        WorldItem::Function(function) => {
                            if function.kind != FunctionKind::Freestanding {
                                continue;
                            }
                            process_func(resolve, function, &mut source)?;
                            source.push_line_empty();
                        }
                        WorldItem::Type(_) => { /* TODO */ }
                    }
                }
            }
            source.close_block();
        }
        source.close_block();

        let file = format!("{}/{}.g.cs", dir, to_upper_camel(name));

        fs::write(&file, source.finish())?;
    }

    for (name, id) in &package.interfaces {
        let interface = resolve.interfaces.get(*id).unwrap();

        let mut source = Source::default();
        let full_name = format!("{0}:{1}/{2}", package.name.namespace, package.name.name, name);

        source.push_line("// <auto-generated />");
        source.push_line("#nullable enable");
        source.push_line_empty();

        source.push_line(&format!("namespace {}", package.to_waas(resolve)?));
        source.open_block();
        {
            source.push_line(&format!("// interface {name}"));
            source.push_docs(&interface.docs);
            source.push_line(&format!("[global::WaaS.ComponentModel.Binding.ComponentInterface(@\"{}\")]", full_name));
            source.push_line(&format!("public partial interface I{}", to_upper_camel(name)));
            source.open_block();
            {
                for (_name, function) in &interface.functions {
                    if function.kind != FunctionKind::Freestanding {
                        continue;
                    }
                    process_func(resolve, function, &mut source)?;
                    source.push_line_empty();
                }

                // types
                for (name, type_id) in &interface.types
                {
                    let ty = resolve.types.get(*type_id).unwrap();

                    // filter defined by itself
                    if let TypeOwner::Interface(owner_id) = ty.owner {
                        if owner_id != *id {
                            continue;
                        }
                    } else {
                        continue;
                    }

                    source.push_docs(&ty.docs);
                    match &ty.kind {
                        TypeDefKind::Record(element) => {
                            source.push_line("[global::WaaS.ComponentModel.Binding.ComponentRecord]");
                            source.push_line(&format!("public readonly partial struct {}", to_upper_camel(name)));
                            source.open_block();
                            {
                                for field in &element.fields {
                                    source.push_docs(&field.docs);
                                    source.push_line("[global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]");
                                    source.push_line(&format!("public {} {} {{ get; init; }}", &field.ty.to_waas(resolve)?, to_upper_camel(&field.name)));
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Resource => {
                            source.push_line(&format!("[global::WaaS.ComponentModel.Binding.ComponentResource(\"{name}\")]"));
                            source.push_line(&format!("public partial interface I{}ResourceImpl : global::WaaS.ComponentModel.Binding.IResourceImpl", to_upper_camel(name)));
                            source.open_block();
                            {
                                for (_name, function) in &interface.functions {
                                    match &function.kind {
                                        FunctionKind::Freestanding => {
                                            continue;
                                        }
                                        FunctionKind::Method(method_type) => {
                                            if type_id != method_type {
                                                continue;
                                            }
                                        }
                                        FunctionKind::Static(method_type) => {
                                            if type_id != method_type {
                                                continue;
                                            }
                                        }
                                        FunctionKind::Constructor(method_type) => {
                                            if type_id != method_type {
                                                continue;
                                            }
                                        }
                                    }
                                    process_func(resolve, function, &mut source)?;
                                    source.push_line_empty();
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Flags(element) => {
                            source.push_line("[global::System.Flags]");
                            source.push_line(&format!("public enum {} : {}", to_upper_camel(name), match element.flags.len() {
                                0..=8 => "byte",
                                9..=16 => "ushort",
                                _ => "uint",
                            }));
                            source.open_block();
                            {
                                for (index, flag) in element.flags.iter().enumerate() {
                                    source.push_docs(&flag.docs);
                                    source.push_line(&format!("{} = 1 << {},", &to_upper_camel(&flag.name), index));
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Variant(element) => {
                            source.push_line("[global::WaaS.ComponentModel.Binding.ComponentVariant, global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]");
                            source.push_line(&format!("public readonly partial struct {}", to_upper_camel(name)));
                            source.open_block();
                            {
                                for case in &element.cases {
                                    source.push_docs(&case.docs);
                                    source.push_line("[global::WaaS.ComponentModel.Binding.ComponentCaseAttribute]");
                                    let ty_string = if let Some(ty) = &case.ty {
                                        if let Type::Id(id) = ty {
                                            if let TypeDefKind::Option(element) = resolve.types.get(*id).unwrap().kind {
                                                format!("global::WaaS.ComponentModel.Binding.Option<{}>?", element.to_waas(resolve)?)
                                            } else {
                                                format!("{}?", ty.to_waas(resolve)?)
                                            }
                                        } else {
                                            format!("{}?", ty.to_waas(resolve)?)
                                        }
                                    } else {
                                        "global::WaaS.ComponentModel.Binding.None?".to_string()
                                    };

                                    source.push_line(&format!("public {} {} {{ get; init; }}", ty_string, to_upper_camel(&case.name)))
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Enum(element) => {
                            source.push_line(&format!("public enum {} : uint", to_upper_camel(name)));
                            source.open_block();
                            {
                                for case in &element.cases {
                                    source.push_docs(&case.docs);
                                    source.push_line(&format!("{},", &to_upper_camel(&case.name)));
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Type(element) => {
                            if element.is_alias_compatible(ty, resolve)? {
                                source.push_alias(&element.to_waas(resolve)?, name, resolve)?;
                            }
                        }
                        TypeDefKind::Tuple(element) => {
                            if let Some(name) = &ty.name {
                                // named tuple
                                source.push_alias(&to_raw_tuple(element, resolve), name, resolve)?;
                            }
                        }
                        _ => {
                            source.push_line(&format!("// {}", &ty.name.clone().unwrap_or("".to_string())));
                            source.push_line_empty();
                        }
                    }
                }
            }
            source.close_block();
        }
        source.close_block();

        let file = format!("{}/{}.g.cs", dir, to_upper_camel(name));

        fs::write(&file, source.finish())?;
    }

    Ok(())
}