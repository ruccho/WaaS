mod source;
mod utils;

use crate::source::Source;
use crate::utils::*;
use anyhow::Result;
use std::fs;
use std::os::windows::fs::FileTypeExt;
use wit_parser::{Function, FunctionKind, PackageId, Resolve, TypeDefKind};

fn main() {
    for entry in fs::read_dir("wasi").unwrap() {
        let entry = entry.unwrap();
        let path = entry.path();
        let path = path.to_str().unwrap();

        let ty = entry.file_type().unwrap();
        if ty.is_dir() || ty.is_symlink_dir() {
            let mut resolve = Resolve::default();
            let (id, _) = resolve.push_dir(format!("{path}/wit")).unwrap();
            process_dir(&resolve, id).unwrap();
        }
    }
}

fn process_func(resolve: &Resolve, function: &Function, source: &mut Source) -> Result<()> {
    let name = &function.name;

    // docs
    source.push_docs(&function.docs);

    // attribute
    source.push_line(&format!("[global::WaaS.ComponentModel.Binding.ComponentApi(@\"{}\")]", name));

    let mut line: String = "".to_string();
    // return type
    let results = &function.results;
    match results.len() {
        0 => line.push_str("void"),
        1 => line.push_str(&results.iter_types().next().unwrap().to_waas(resolve)?),
        _ => {
            return Err(anyhow::anyhow!("multiple return values not supported"))
        }
    }

    // function name

    let name = match &function.kind {
        FunctionKind::Freestanding => {
            &function.name
        }
        FunctionKind::Method(method_type) => {
            if name.starts_with("[method]") {
                &name[name.chars().position(|c| c == '.').unwrap() + 1..]
            } else {
                name
            }
        }
        FunctionKind::Static(method_type) => {
            if name.starts_with("[static]") {
                &name[name.chars().position(|c| c == '.').unwrap() + 1..]
            } else {
                name
            }
        }
        FunctionKind::Constructor(method_type) => {
            if name.starts_with("[constructor]") {
                &name.strip_prefix("[constructor]").unwrap().to_string()
            } else {
                name
            }
        }
    };

    line.push(' ');
    line.push_str(&to_upper_camel(name));
    line.push('(');

    // params
    let mut first = true;
    for (name, ty) in &function.params {
        if first {
            first = false;
        } else {
            line.push_str(", ");
        }

        line.push_str(&ty.to_waas(resolve)?);
        line.push_str(" @");
        line.push_str(&to_lower_camel(name));
    }

    line.push_str(");");
    source.push_line(&line);

    Ok(())
}

fn process_dir(resolve: &Resolve, package_id: PackageId) -> Result<()> {
    let package = resolve.packages.get(package_id).unwrap();
    for (name, id) in &package.interfaces {
        let interface = resolve.interfaces.get(*id).unwrap();

        let mut source = Source::default();

        source.push_line("// <auto-generated />");
        source.push_line("#nullable enable");
        source.push_line_empty();

        source.push_line(&format!("namespace {}", package.to_waas(resolve)?));
        source.open_block();
        {
            source.push_docs(&interface.docs);
            source.push_line(&format!("[global::WaaS.ComponentModel.Binding.ComponentInterface(@\"{}\")]", name));
            source.push_line(&format!("public partial interface I{}", to_upper_camel(name)));
            source.open_block();
            {
                for (name, function) in &interface.functions {
                    if function.kind != FunctionKind::Freestanding {
                        continue;
                    }
                    process_func(resolve, function, &mut source)?;
                    source.push_line_empty();
                }

                // types
                for (name, id) in &interface.types
                {
                    let ty = resolve.types.get(*id).unwrap();
                    source.push_docs(&ty.docs);
                    match &ty.kind {
                        TypeDefKind::Record(element) => {
                            source.push_line("[global::WaaS.ComponentModel.Binding.ComponentRecord]");
                            source.push_line(&format!("public readonly partial struct {}", to_upper_camel(name)));
                            source.open_block();
                            {
                                for field in &element.fields {
                                    source.push_docs(&field.docs);
                                    source.push_line("[global::WaaS.ComponentModel.Binding.ComponentFieldAttribute]");
                                    source.push_line(&format!("public {} {} {{ get; init; }}", &field.ty.to_waas(resolve)?, to_upper_camel(&field.name)));
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Resource => {
                            source.push_line("[global::WaaS.ComponentModel.Binding.ComponentResource]");
                            source.push_line(&format!("public partial interface I{}Resource : global::WaaS.ComponentModel.Runtime.IResourceType", to_upper_camel(name)));
                            source.open_block();
                            {
                                for (name, function) in &interface.functions {
                                    match &function.kind {
                                        FunctionKind::Freestanding => {
                                            continue;
                                        }
                                        FunctionKind::Method(method_type) => {
                                            if id != method_type {
                                                continue;
                                            }
                                        }
                                        FunctionKind::Static(method_type) => {
                                            if id != method_type {
                                                continue;
                                            }
                                        }
                                        FunctionKind::Constructor(method_type) => {
                                            if id != method_type {
                                                continue;
                                            }
                                        }
                                    }
                                    process_func(resolve, function, &mut source)?;
                                    source.push_line_empty();
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                            /*
                            source.push_line(&format!("{} {} {{ get; }}", ty.to_waas(resolve)?, to_upper_camel(&name)));
                            source.push_line_empty();
                            */
                        }
                        TypeDefKind::Flags(element) => {
                            source.push_line("[global::System.Flags]");
                            source.push_line(&format!("public enum {} : {}", to_upper_camel(name), match element.flags.len() {
                                0..=8 => "byte",
                                9..=16 => "ushort",
                                _ => "uint",
                            }));
                            source.open_block();
                            {
                                for (index, flag) in element.flags.iter().enumerate() {
                                    source.push_docs(&flag.docs);
                                    source.push_line(&format!("{} = 1 << {},", &to_upper_camel(&flag.name), index));
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Variant(element) => {
                            source.push_line("[global::WaaS.ComponentModel.Binding.ComponentVariant]");
                            source.push_line(&format!("public readonly partial struct {}", to_upper_camel(name)));
                            source.open_block();
                            {
                                for case in &element.cases {
                                    source.push_docs(&case.docs);
                                    source.push_line("[global::WaaS.ComponentModel.Binding.ComponentCaseAttribute]");
                                    let ty = if let Some(ty) = &case.ty {
                                        if ty.is_value_type(resolve)? {
                                            format!("{}?", ty.to_waas(resolve)?)
                                        } else {
                                            format!("global::WaaS.ComponentModel.Binding.Option<{}>", ty.to_waas(resolve)?)
                                        }
                                    } else {
                                        "global::WaaS.ComponentModel.Binding.None?".to_string()
                                    };

                                    source.push_line(&format!("public {} {} {{ get; init; }}", ty, to_upper_camel(&case.name)))
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Enum(element) => {
                            source.push_line(&format!("public enum {} : uint", to_upper_camel(name)));
                            source.open_block();
                            {
                                for case in &element.cases {
                                    source.push_docs(&case.docs);
                                    source.push_line(&format!("{},", &to_upper_camel(&case.name)));
                                }
                            }
                            source.close_block();
                            source.push_line_empty();
                        }
                        TypeDefKind::Type(element) => {
                            if element.is_alias_compatible(ty, resolve)? {
                                source.push_alias(&element.to_waas(resolve)?, name, resolve)?;
                            }
                        }
                        TypeDefKind::Tuple(element) => {
                            if let Some(name) = &ty.name {
                                // named tuple
                                source.push_alias(&to_raw_tuple(element, resolve), name, resolve)?;
                            }
                        }
                        _ => {
                            source.push_line(&format!("// {}", &ty.name.clone().unwrap_or("".to_string())));
                            source.push_line_empty();
                        }
                    }
                }
            }
            source.close_block();
        }
        source.close_block();

        let dir = format!("out/{}/{}", package.name.namespace, package.name.name);
        fs::create_dir_all(&dir)?;

        let file = format!("{}/{}.g.cs", dir, to_upper_camel(name));

        fs::write(&file, source.finish())?;
    }

    Ok(())
}