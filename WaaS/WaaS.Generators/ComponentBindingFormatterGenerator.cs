using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace WaaS.Generators;

[Generator(LanguageNames.CSharp)]
public class ComponentBindingFormatterGenerator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat ForTypeDeclaration = new(
        SymbolDisplayGlobalNamespaceStyle.Omitted,
        SymbolDisplayTypeQualificationStyle.NameOnly,
        SymbolDisplayFormat.FullyQualifiedFormat.GenericsOptions,
        SymbolDisplayFormat.FullyQualifiedFormat.MemberOptions,
        SymbolDisplayFormat.FullyQualifiedFormat.DelegateStyle,
        SymbolDisplayFormat.FullyQualifiedFormat.ExtensionMethodStyle,
        SymbolDisplayFormat.FullyQualifiedFormat.ParameterOptions,
        SymbolDisplayFormat.FullyQualifiedFormat.PropertyStyle,
        SymbolDisplayFormat.FullyQualifiedFormat.LocalOptions,
        SymbolDisplayFormat.FullyQualifiedFormat.KindOptions,
        SymbolDisplayFormat.FullyQualifiedFormat.MiscellaneousOptions
    );


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        {
            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                "WaaS.ComponentModel.Binding.ComponentRecordAttribute",
                static (node, ct) => true,
                (context, ct) => context);

            context.RegisterSourceOutput(source,
                (source, context) => EmitFormatter(source, context, FormatterKind.Record));
        }
        {
            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                "WaaS.ComponentModel.Binding.ComponentVariantAttribute",
                static (node, ct) => true,
                (context, ct) => context);

            context.RegisterSourceOutput(source,
                (source, context) => EmitFormatter(source, context, FormatterKind.Variant));
        }
        {
            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                "WaaS.ComponentModel.Binding.ComponentAliasAttribute",
                static (node, ct) => true,
                (context, ct) => context);

            context.RegisterSourceOutput(source,
                (source, context) => EmitFormatter(source, context, FormatterKind.Alias));
        }
    }

    private void EmitFormatter(SourceProductionContext source, GeneratorAttributeSyntaxContext context,
        FormatterKind kind)
    {
        StringBuilder sourceBuilder = new();

        var symbol = context.TargetSymbol;

        if (symbol is not INamedTypeSymbol namedSymbol) return;

        var identifier = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)
            .WithGenericsOptions(SymbolDisplayGenericsOptions.None));
        if (namedSymbol.Arity > 0) identifier += $"`{namedSymbol.Arity}";

        sourceBuilder.AppendLine(
/* lang=c#  */"""
              // <auto-generated />
              #nullable enable
              using System;
              """);

        // TODO: nested class check

        if (!namedSymbol.ContainingNamespace.IsGlobalNamespace)
            sourceBuilder.AppendLine(
                /* lang=c#  */
                $$"""
                  namespace {{namedSymbol.ContainingNamespace}}
                  {
                  """);

        // nested types

        static void PrintNestedTypeOpeners(StringBuilder sourceBuilder, INamedTypeSymbol symbol)
        {
            var containingSymbol = symbol.ContainingSymbol;
            if (containingSymbol is INamedTypeSymbol namedSymbol) PrintNestedTypeOpeners(sourceBuilder, namedSymbol);

            var kind = symbol.TypeKind switch
            {
                TypeKind.Class => "class",
                TypeKind.Interface => "interface",
                TypeKind.Struct => "struct",
                _ => throw new ArgumentOutOfRangeException()
            };
            sourceBuilder.AppendLine(
                /* lang=c#  */
                $$"""
                  partial {{kind}} {{symbol.ToDisplayString(ForTypeDeclaration)}}
                  {
                  """);
        }

        if (namedSymbol.ContainingSymbol is INamedTypeSymbol containingSymbol)
            PrintNestedTypeOpeners(sourceBuilder, containingSymbol);

        var name = namedSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // TODO: generics
        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                    partial {{namedSymbol.TypeKind switch {
                        TypeKind.Class => "class",
                        TypeKind.Struct => "struct",
                        _ => "/* unknown */"
                    }}} {{namedSymbol.ToDisplayString(ForTypeDeclaration)}}
                    {
                        static {{namedSymbol.Name}}()
                        {
                            global::WaaS.ComponentModel.Binding.FormatterProvider.Register<{{name}}>(new __GeneratedFormatter());
                            StaticConstructor();
                        }
                        
                        static partial void StaticConstructor();
                
                        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                        private class __GeneratedFormatter : global::WaaS.ComponentModel.Binding.IFormatter<{{name}}>
                        {
                """);

        StringBuilder? memberBuilder = null;
        switch (kind)
        {
            case FormatterKind.Record:
                EmitRecordFormatterBody(namedSymbol, sourceBuilder);
                break;
            case FormatterKind.Variant:
                EmitVariantFormatterBody(namedSymbol, sourceBuilder, memberBuilder ??= new StringBuilder());
                break;
            case FormatterKind.Alias:
                EmitAliasFormatterBody(namedSymbol, sourceBuilder);
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(kind), kind, null);
        }


        sourceBuilder.AppendLine(
/* lang=c#    */"""
                        }
                """);

        if (memberBuilder != null) sourceBuilder.Append(memberBuilder);

        sourceBuilder.AppendLine(
/* lang=c#    */"""
                    }
                """);

        static void PrintNestedTypeClosers(StringBuilder sourceBuilder, INamedTypeSymbol symbol)
        {
            var kind = symbol.TypeKind switch
            {
                TypeKind.Class => "class",
                TypeKind.Interface => "interface",
                TypeKind.Struct => "struct",
                _ => throw new ArgumentOutOfRangeException()
            };
            sourceBuilder.AppendLine(
                /* lang=c#  */
                $$"""
                  } // partial {{kind}} {{symbol.ToDisplayString(ForTypeDeclaration)}}
                  """);
            var containingSymbol = symbol.ContainingSymbol;
            if (containingSymbol is INamedTypeSymbol namedSymbol) PrintNestedTypeClosers(sourceBuilder, namedSymbol);
        }

        if (namedSymbol.ContainingSymbol is INamedTypeSymbol containingSymbol1)
            PrintNestedTypeClosers(sourceBuilder, containingSymbol1);

        if (!namedSymbol.ContainingNamespace.IsGlobalNamespace)
            sourceBuilder.AppendLine(
                /* lang=c#  */
                $$"""
                  } // namespace {{namedSymbol.ContainingNamespace}}
                  """);


        source.AddSource($"{identifier}.Formatter.g.cs", sourceBuilder.ToString());
    }

    private static ITypeSymbol GetMemberType(ISymbol member)
    {
        return member switch
        {
            IFieldSymbol field => field.Type,
            IPropertySymbol property => property.Type,
            _ => throw new ArgumentOutOfRangeException(nameof(member), member, null)
        };
    }

    private static void EmitRecordFormatterBody(INamedTypeSymbol namedSymbol, StringBuilder sourceBuilder)
    {
        var name = namedSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var members = namedSymbol.GetRecordMembers().ToArray();

        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                            public async global::STask.STask<{{name}}> PullAsync(global::WaaS.ComponentModel.Binding.Pullable pullable)
                            {
                                var prelude = await pullable.PullPrimitiveValueAsync<global::WaaS.ComponentModel.Binding.RecordPrelude>();
                                pullable = prelude.BodyPullable;
                                
                                return new {{name}}()
                                {
                """);

        foreach (var member in members)
        {
            var memberType = GetMemberType(member);
            bool isNullable;
            if (memberType.TryGetNullableElement(out var elementType))
            {
                memberType = elementType!;
                isNullable = true;
            }
            else
            {
                isNullable = memberType.NullableAnnotation is NullableAnnotation.Annotated;
            }

            var memberTypeExpression = isNullable
                ? $"global::WaaS.ComponentModel.Binding.Option<{memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>"
                : memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            sourceBuilder.Append(
                /* lang=c#  */
                $$"""
                                      {{member.Name}} = 
                  """);
            if (isNullable) sourceBuilder.Append("global::WaaS.ComponentModel.Binding.OptionExtensions.ToNullable(");

            sourceBuilder.Append($"await pullable.PullValueAsync<{memberTypeExpression}>()");
            if (isNullable) sourceBuilder.Append(")");

            sourceBuilder.AppendLine(",");
        }

        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                                };
                            }
                                
                            public void Push({{name}} value, global::WaaS.ComponentModel.Runtime.ValuePusher pusher)
                            {
                                pusher = pusher.PushRecord();
                """);

        foreach (var member in members)
        {
            var memberType = GetMemberType(member);
            bool isNullable;
            if (memberType.TryGetNullableElement(out var elementType))
            {
                memberType = elementType!;
                isNullable = true;
            }
            else
            {
                isNullable = memberType.NullableAnnotation is NullableAnnotation.Annotated;
            }

            var memberTypeExpression = isNullable
                ? $"global::WaaS.ComponentModel.Binding.Option<{memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>"
                : memberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            sourceBuilder.Append(
/* lang=c#  */$$"""
                                global::WaaS.ComponentModel.Binding.FormatterProvider.GetFormatter<{{memberTypeExpression}}>().Push(
                """);

            if (isNullable) sourceBuilder.Append("global::WaaS.ComponentModel.Binding.OptionExtensions.ToOption(");

            sourceBuilder.Append($"value.{member.Name}");

            if (isNullable) sourceBuilder.Append(")");

            sourceBuilder.AppendLine(", pusher);");
        }

        sourceBuilder.AppendLine(
/* lang=c#  */"""
                          }
              """);
    }

    private static void EmitVariantFormatterBody(INamedTypeSymbol namedSymbol, StringBuilder bodyBuilder,
        StringBuilder memberBuilder)
    {
        var name = namedSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var members = namedSymbol.GetVariantMembers().ToArray();

        bodyBuilder.AppendLine(
/* lang=c#  */$$"""
                            public async global::STask.STask<{{name}}> PullAsync(global::WaaS.ComponentModel.Binding.Pullable pullable)
                            {
                                var prelude = await pullable.PullPrimitiveValueAsync<global::WaaS.ComponentModel.Binding.VariantPrelude>();
                                pullable = prelude.BodyPullable;
                                
                                return prelude.CaseIndex switch
                                {
                """);

        for (var i = 0; i < members.Length; i++)
        {
            var member = members[i];
            var memberType = GetMemberType(member);
            if (memberType.TryGetNullableElement(out var elementType)) memberType = elementType!;
            var isNone = memberType.Matches("WaaS.ComponentModel.Binding.None");
            var valueExpression = isNone
                ? "default(global::WaaS.ComponentModel.Binding.None)"
                : $"await pullable.PullValueAsync<{GetMemberType(member).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>()";

            bodyBuilder.AppendLine(
/* lang=c#  */$$"""
                                    {{i}} => new {{name}}() { Case = VariantCase.{{member.Name}}, {{member.Name}} = {{valueExpression}} },
                """);
        }

        bodyBuilder.AppendLine(
/* lang=c#  */$$"""
                                    _ => throw new global::System.IndexOutOfRangeException()
                                };
                            }
                                
                            public void Push({{name}} value, global::WaaS.ComponentModel.Runtime.ValuePusher pusher)
                            {
                                pusher = pusher.PushVariant((int)value.Case);
                                switch (value.Case)
                                {
                """);

        foreach (var member in members)
        {
            var memberType = GetMemberType(member);
            var isNone = memberType.TryGetNullableElement(out var elementType) &&
                         elementType!.Matches("WaaS.ComponentModel.Binding.None");
            bodyBuilder.AppendLine(
/* lang=c#  */$$"""
                                    case VariantCase.{{member.Name}}:
                """);
            if (!isNone)
                bodyBuilder.AppendLine(
/* lang=c#  */$$"""
                                        global::WaaS.ComponentModel.Binding.FormatterProvider.GetFormatter<{{GetMemberType(member).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}}>().Push(value.{{member.Name}} ?? throw new global::System.InvalidOperationException(), pusher);
                """);
            bodyBuilder.AppendLine(
/* lang=c#  */"""                        break;""");
        }

        bodyBuilder.AppendLine(
/* lang=c#    */"""
                                    default:
                                        throw new global::System.IndexOutOfRangeException();
                                }
                            }
                """);

        // emit members
        memberBuilder.AppendLine(
/* lang=c#    */"""
                        public VariantCase Case { get; private init; }
                        public enum VariantCase
                        {
                """);
        foreach (var member in members)
            memberBuilder.AppendLine(
                /* lang=c#  */
                $$"""
                              {{member.Name}},
                  """);

        memberBuilder.AppendLine(
/* lang=c#    */"""
                        }
                """);
    }

    private static void EmitAliasFormatterBody(INamedTypeSymbol namedSymbol, StringBuilder sourceBuilder)
    {
        var name = namedSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var targetType = namedSymbol.GetAttributes()
            .First(attr => attr.AttributeClass?.Matches("WaaS.ComponentModel.Binding.ComponentAliasAttribute") ?? false)
            .ConstructorArguments[0].Value as ITypeSymbol;

        if (targetType is null) return;

        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                            public async global::STask.STask<{{name}}> PullAsync(global::WaaS.ComponentModel.Binding.Pullable pullable)
                            {
                                return await pullable.PullValueAsync<{{targetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}}>();
                            }
                                
                            public void Push({{name}} value, global::WaaS.ComponentModel.Runtime.ValuePusher pusher)
                            {
                                global::WaaS.ComponentModel.Binding.FormatterProvider.GetFormatter<{{targetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}}>().Push(value, pusher);
                            }
                """);
    }

    private enum FormatterKind
    {
        Record,
        Variant,
        Alias
    }
}