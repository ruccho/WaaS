using System.Text;
using ConsoleAppFramework;
using System.Text.Json;
using System.Text.Json.Serialization;

await ConsoleApp.RunAsync(args, async () =>
{
    CdpSchema schema;
    await using (var file = File.OpenRead("devtools-protocol/json/js_protocol.json"))
    {
        schema = await JsonSerializer.DeserializeAsync<CdpSchema>(file, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower
        }) ?? throw new InvalidOperationException();
    }

    var context = new TypeResolutionContext(schema);

    foreach (var domain in schema.Domains)
    {
        domain.ResolveTypes(context);
    }

    StringBuilder sourceBuilder = new();

    static void AppendProperty(CdpProperty prop, StringBuilder sourceBuilder)
    {
        if (!string.IsNullOrEmpty(prop.Description))
        {
            sourceBuilder.AppendLine("            /// <summary>");
            foreach (var line in prop.Description.Split('\n'))
            {
                sourceBuilder.Append("            ///     ");
                sourceBuilder.AppendLine(line);
            }

            sourceBuilder.AppendLine("            /// </summary>");
        }

        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                            {{prop.ToCSharp()}} {{ToUpperCamel(prop.Name)}} { get; }
                """);
    }

    sourceBuilder.AppendLine($"// <auto-generated />");
    sourceBuilder.AppendLine($"#nullable enable");
    sourceBuilder.AppendLine();
    sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                namespace Cdp
                {
                """);

    foreach (var domain in schema.Domains)
    {
        if (!string.IsNullOrEmpty(domain.Description))
        {
            sourceBuilder.AppendLine("    /// <summary>");
            foreach (var line in domain.Description.Split('\n'))
            {
                sourceBuilder.Append("    ///     ");
                sourceBuilder.AppendLine(line);
            }

            sourceBuilder.AppendLine("    /// </summary>");
        }

        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                    public interface I{{domain.Domain}} : global::Cdp.IDomain
                    {
                """);

        foreach (var command in domain.Commands ?? [])
        {
            if (!string.IsNullOrEmpty(command.Description))
            {
                sourceBuilder.AppendLine("        /// <summary>");
                foreach (var line in command.Description.Split('\n'))
                {
                    sourceBuilder.Append("        ///     ");
                    sourceBuilder.AppendLine(line);
                }

                sourceBuilder.AppendLine("        /// </summary>");
            }

            var name = ToUpperCamel(command.Name);
            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        global::System.Threading.Tasks.Task<I{{name}}Returns> {{name}}Async(I{{name}}Params parameters);
                """);
        }

        foreach (var type in domain.Types)
        {
            if (type is not CdpTypeObject obj) continue;

            if (!string.IsNullOrEmpty(type.Description))
            {
                sourceBuilder.AppendLine("        /// <summary>");
                foreach (var line in type.Description.Split('\n'))
                {
                    sourceBuilder.Append("        ///     ");
                    sourceBuilder.AppendLine(line);
                }

                sourceBuilder.AppendLine("        /// </summary>");
            }

            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        public interface I{{type.Id}} : global::Cdp.IObject
                        {
                """);
            foreach (var prop in obj.Properties ?? [])
            {
                AppendProperty(prop, sourceBuilder);
            }

            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        }
                """);
        }

        foreach (var command in domain.Commands ?? [])
        {
            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        public interface I{{ToUpperCamel(command.Name)}}Params : global::Cdp.ICommandParams
                        {
                """);

            foreach (var prop in command.Parameters)
            {
                AppendProperty(prop, sourceBuilder);
            }

            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        }
                """);
            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        public interface I{{ToUpperCamel(command.Name)}}Returns : global::Cdp.ICommandReturns
                        {
                """);

            foreach (var prop in command.Returns)
            {
                AppendProperty(prop, sourceBuilder);
            }

            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        }
                """);
        }

        foreach (var @event in domain.Events ?? [])
        {
            if (!string.IsNullOrEmpty(@event.Description))
            {
                sourceBuilder.AppendLine("        /// <summary>");
                foreach (var line in @event.Description.Split('\n'))
                {
                    sourceBuilder.Append("        ///     ");
                    sourceBuilder.AppendLine(line);
                }

                sourceBuilder.AppendLine("        /// </summary>");
            }

            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        public interface I{{ToUpperCamel(@event.Name)}}Params : global::Cdp.IEventParams
                        {
                """);

            foreach (var prop in @event.Parameters)
            {
                AppendProperty(prop, sourceBuilder);
            }

            sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                        }
                """);
        }

        sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                    }
                """);
    }
    
    // domain selector
    

    sourceBuilder.AppendLine(
/* lang=c#  */$$"""
                }
                """);

    // Console.WriteLine(sourceBuilder.ToString());
    await File.WriteAllTextAsync("../Cdp/Js.gen.cs", sourceBuilder.ToString(), Encoding.UTF8);
});

static string ToUpperCamel(ReadOnlySpan<char> lowerCamel)
{
    Span<char> result = stackalloc char[lowerCamel.Length];
    lowerCamel.CopyTo(result);
    result[0] = char.ToUpper(result[0]);
    return new string(result);
}

internal interface ITypeResolutionContext
{
    void Resolve(string domain, UnresolvedCdpType unresolved, Action<CdpType> setter);
}

public class TypeResolutionContext : ITypeResolutionContext
{
    private readonly Dictionary<UnresolvedCdpType, List<Action<CdpType>>> delayedSetters = new();
    private readonly Dictionary<UnresolvedCdpType, CdpType> types = new();
    private readonly Dictionary<string, UnresolvedCdpType> typesById = new();
    private readonly HashSet<UnresolvedCdpType> inResolution = new();

    public TypeResolutionContext(CdpSchema schema)
    {
        foreach (var domain in schema.Domains)
        {
            foreach (var type in domain.UnresolvedTypes)
            {
                typesById[$"{domain.Domain}.{type.Id}"] = type;
            }
        }
    }

    public void GetReference(string domain, string id, Action<CdpType> setter)
    {
        var dot = id.IndexOf('.');
        if (dot == -1) id = $"{domain}.{id}";
        else domain = id[..dot];

        Resolve(domain, typesById[id], setter);
    }

    public void Resolve(string domain, UnresolvedCdpType unresolved, Action<CdpType> setter)
    {
        if (!types.TryGetValue(unresolved, out var type))
        {
            if (!string.IsNullOrEmpty(unresolved.Ref))
            {
                GetReference(domain, unresolved.Ref, setter);
                return;
            }

            if (!inResolution.Add(unresolved))
            {
                if (!delayedSetters.TryGetValue(unresolved, out var setters))
                {
                    delayedSetters[unresolved] = setters = new();
                }

                setters.Add(setter);
                return;
            }
            else
            {
                types[unresolved] = type = unresolved.ResolveFirstTime(this, domain);
                if (delayedSetters.TryGetValue(unresolved, out var setters))
                {
                    foreach (var otherSetter in setters)
                    {
                        otherSetter(type);
                    }
                }
            }
        }

        setter(type);
    }

    public void ResolveDelayed(UnresolvedCdpType unresolved, Action<CdpType> setter)
    {
    }
}


public record CdpSchema
{
    public Version Version { get; init; }
    public CdpDomain[] Domains { get; init; }
}

public record struct Version
{
    public string Major { get; init; }
    public string Minor { get; init; }
}

public class CdpDomain
{
    public string Domain { get; init; }
    public string? Description { get; init; }
    public bool Deprecated { get; init; }
    public string[] Dependencies { get; init; }
    [JsonPropertyName("types")] public UnresolvedCdpType[] UnresolvedTypes { get; init; }
    public CdpCommand[]? Commands { get; init; }
    public CdpEvent[]? Events { get; init; }
    [JsonIgnore] public CdpType[] Types { get; private set; }

    internal void ResolveTypes(ITypeResolutionContext context)
    {
        CdpType[] types = new CdpType[UnresolvedTypes.Length];
        for (var i = 0; i < UnresolvedTypes.Length; i++)
        {
            var capturedI = i;
            context.Resolve(Domain, UnresolvedTypes[i], resolved => types[capturedI] = resolved);
        }

        foreach (var command in Commands ?? [])
        {
            command.ResolveTypes(context, Domain);
        }

        foreach (var @event in Events ?? [])
        {
            @event.ResolveTypes(context, Domain);
        }

        Types = types;
    }
}

public record UnresolvedCdpType
{
    public string? Name { get; init; }
    public string Id { get; init; }
    public string Description { get; init; }
    public string? Type { get; init; }
    public UnresolvedCdpType[]? Properties { get; init; }
    [JsonPropertyName("$ref")] public string? Ref { get; init; }
    public bool? Optional { get; init; }
    public string[]? Enum { get; init; }
    public UnresolvedCdpType? Items { get; init; }

    internal CdpType ResolveFirstTime(ITypeResolutionContext ctx, string currentDomain)
    {
        if (!string.IsNullOrEmpty(Ref))
        {
            throw new InvalidOperationException();
        }

        return Type switch
        {
            "object" => new CdpTypeObject(this, ctx, Properties ?? [], currentDomain),
            "string" when Enum != null => new CdpTypeEnum(this)
            {
                Enum = Enum
            },
            "string" => new CdpTypeString(this),
            "integer" => new CdpTypeInteger(this),
            "array" => new CdpTypeArray(this, ctx, Items, currentDomain),
            "any" => new CdpTypeAny(this),
            "boolean" => new CdpTypeBoolean(this),
            "number" => new CdpTypeNumber(this),
            _ => throw new InvalidOperationException()
        };
    }
}

public abstract record CdpType
{
    public string Id { get; init; }
    public string Description { get; init; }

    protected CdpType(UnresolvedCdpType unresolved)
    {
        Id = unresolved.Id;
        Description = unresolved.Description;
    }

    public abstract string ToCSharp();
}

public record CdpTypeAny : CdpType
{
    public CdpTypeAny(UnresolvedCdpType unresolved) : base(unresolved)
    {
    }

    public override string ToCSharp() => "object";
}

public record CdpTypeNumber : CdpType
{
    public CdpTypeNumber(UnresolvedCdpType unresolved) : base(unresolved)
    {
    }

    public override string ToCSharp() => "double";
}


public record CdpTypeBoolean : CdpType
{
    public CdpTypeBoolean(UnresolvedCdpType unresolved) : base(unresolved)
    {
    }

    public override string ToCSharp() => "bool";
}

public record CdpTypeArray : CdpType
{
    public CdpType Items { get; private set; }

    internal CdpTypeArray(UnresolvedCdpType unresolved, ITypeResolutionContext ctx, UnresolvedCdpType items,
        string domain) : base(unresolved)
    {
        ctx.Resolve(domain, items, resolved => Items = resolved);
    }

    public override string ToCSharp() => $"{Items.ToCSharp()}[]";
}

public record CdpTypeObject : CdpType
{
    private readonly string domain;
    public CdpProperty[]? Properties { get; }

    internal CdpTypeObject(UnresolvedCdpType unresolved, ITypeResolutionContext ctx, UnresolvedCdpType[] properties,
        string domain) : base(unresolved)
    {
        this.domain = domain;
        Properties = new CdpProperty[properties.Length];
        for (var i = 0; i < properties.Length; i++)
        {
            var capturedI = i;
            var prop = properties[i];
            ctx.Resolve(domain, properties[i],
                resolved => Properties[capturedI] = new CdpProperty(resolved, prop));
        }
    }

    public override string ToCSharp() => string.IsNullOrEmpty(Id)
        ? "global::System.Collections.Generic.Dictionary<string, object>"
        : $"global::Cdp.I{domain}.I{Id}";
}

public record struct CdpProperty
{
    public CdpProperty(CdpType Type, UnresolvedCdpType source)
    {
        this.Name = source.Name ?? throw new InvalidOperationException();
        this.Type = Type;
        this.IsOptional = source.Optional ?? false;
        this.Description = source.Description;
    }

    public string ToCSharp()
    {
        var type = Type.ToCSharp();
        return IsOptional ? $"{type}?" : type;
    }

    public string Name { get; set; }
    public CdpType Type { get; set; }
    public bool IsOptional { get; set; }
    public string Description { get; set; }

    public readonly void Deconstruct(out string Name, out CdpType Type, out bool IsOptional, out string Description)
    {
        Name = this.Name;
        Type = this.Type;
        IsOptional = this.IsOptional;
        Description = this.Description;
    }
}

public record CdpTypeString : CdpType
{
    public CdpTypeString(UnresolvedCdpType unresolved) : base(unresolved)
    {
    }

    public override string ToCSharp() => "string";
}

public record CdpTypeEnum : CdpTypeString
{
    public string[]? Enum { get; init; }

    public CdpTypeEnum(UnresolvedCdpType unresolved) : base(unresolved)
    {
    }
}

public record CdpTypeInteger : CdpType
{
    public CdpTypeInteger(UnresolvedCdpType unresolved) : base(unresolved)
    {
    }

    public override string ToCSharp() => "long";
}

public record CdpCommand
{
    public string Name { get; init; }
    public string Description { get; init; }
    [JsonPropertyName("parameters")] public UnresolvedCdpType[]? UnresolvedParameters { get; init; }
    [JsonPropertyName("returns")] public UnresolvedCdpType[]? UnresolvedReturns { get; init; }
    [JsonIgnore] public CdpProperty[] Parameters { get; private set; }
    [JsonIgnore] public CdpProperty[] Returns { get; private set; }

    internal void ResolveTypes(ITypeResolutionContext context, string domain)
    {
        CdpProperty[] parameters = new CdpProperty[UnresolvedParameters?.Length ?? 0];
        for (var i = 0; i < parameters.Length; i++)
        {
            var capturedI = i;
            var prop = UnresolvedParameters[i];
            context.Resolve(domain, UnresolvedParameters![i],
                resolved => parameters[capturedI] = new CdpProperty(resolved, prop));
        }

        Parameters = parameters;

        CdpProperty[] returns = new CdpProperty[UnresolvedReturns?.Length ?? 0];
        for (var i = 0; i < returns.Length; i++)
        {
            var capturedI = i;
            var prop = UnresolvedReturns[i];
            context.Resolve(domain, UnresolvedReturns![i],
                resolved => returns[capturedI] = new CdpProperty(resolved, prop));
        }

        Returns = returns;
    }
}

public record CdpEvent
{
    public string Name { get; init; }
    public string Description { get; init; }
    [JsonPropertyName("parameters")] public UnresolvedCdpType[]? UnresolvedParameters { get; init; }
    [JsonIgnore] public CdpProperty[] Parameters { get; private set; }

    internal void ResolveTypes(ITypeResolutionContext context, string domain)
    {
        CdpProperty[] parameters = new CdpProperty[UnresolvedParameters?.Length ?? 0];
        for (var i = 0; i < parameters.Length; i++)
        {
            var capturedI = i;
            var prop = UnresolvedParameters![i];
            context.Resolve(domain, UnresolvedParameters![i],
                resolved => parameters[capturedI] = new(resolved, prop));
        }

        Parameters = parameters;
    }
}